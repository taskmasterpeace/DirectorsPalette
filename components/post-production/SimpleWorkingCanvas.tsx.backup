'use client'

import { 
  useEffect, 
  useRef, 
  useCallback, 
  useState,
  forwardRef,
  useImperativeHandle
} from 'react'
import { Card, CardContent } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { 
  ZoomIn, 
  ZoomOut, 
  Maximize2
} from 'lucide-react'

interface SimpleCanvasProps {
  tool: 'select' | 'brush' | 'rectangle' | 'circle' | 'line' | 'arrow' | 'text' | 'eraser'
  brushSize: number
  color: string
  onObjectsChange?: (count: number) => void
}

export interface SimpleCanvasRef {
  undo: () => void
  redo: () => void
  clear: () => void
  exportCanvas: (format: string) => string
}

const SimpleWorkingCanvas = forwardRef<SimpleCanvasRef, SimpleCanvasProps>(({
  tool,
  brushSize,
  color,
  onObjectsChange
}, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const ctxRef = useRef<CanvasRenderingContext2D | null>(null)
  const [isDrawing, setIsDrawing] = useState(false)
  const [startPoint, setStartPoint] = useState<{ x: number; y: number } | null>(null)
  const [objects, setObjects] = useState<any[]>([])
  const [history, setHistory] = useState<ImageData[]>([])
  const [historyIndex, setHistoryIndex] = useState(-1)
  const [zoom, setZoom] = useState(1)

  // Initialize canvas
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    // Set canvas size
    canvas.width = 800
    canvas.height = 450
    
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Set white background
    ctx.fillStyle = '#ffffff'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    
    ctxRef.current = ctx
    
    // Save initial state
    saveState()
    console.log('âœ… SIMPLE CANVAS - Initialized successfully')
  }, [])

  // Update object count
  useEffect(() => {
    onObjectsChange?.(objects.length)
  }, [objects.length, onObjectsChange])

  const saveState = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const imageData = ctxRef.current?.getImageData(0, 0, canvas.width, canvas.height)
    if (!imageData) return

    // Clear forward history
    const newHistory = history.slice(0, historyIndex + 1)
    newHistory.push(imageData)
    
    // Limit history size
    if (newHistory.length > 20) {
      newHistory.shift()
    } else {
      setHistoryIndex(newHistory.length - 1)
    }
    
    setHistory(newHistory)
  }, [history, historyIndex])

  const drawArrow = useCallback((ctx: CanvasRenderingContext2D, fromX: number, fromY: number, toX: number, toY: number) => {
    const headlen = 15 // Length of arrowhead
    const angle = Math.atan2(toY - fromY, toX - fromX)

    // Draw the line
    ctx.beginPath()
    ctx.moveTo(fromX, fromY)
    ctx.lineTo(toX, toY)
    ctx.stroke()

    // Draw the arrowhead
    ctx.beginPath()
    ctx.moveTo(toX, toY)
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6))
    ctx.moveTo(toX, toY)
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6))
    ctx.stroke()
  }, [])

  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current
    const ctx = ctxRef.current
    if (!canvas || !ctx) return

    const rect = canvas.getBoundingClientRect()
    const x = (e.clientX - rect.left) / zoom
    const y = (e.clientY - rect.top) / zoom

    console.log(`ðŸŽ¯ MOUSE DOWN - ${tool} tool at (${Math.round(x)}, ${Math.round(y)})`)

    setIsDrawing(true)
    setStartPoint({ x, y })

    // Set drawing properties
    ctx.strokeStyle = color
    ctx.lineWidth = brushSize
    ctx.lineCap = 'round'
    ctx.lineJoin = 'round'

    if (tool === 'brush') {
      ctx.beginPath()
      ctx.moveTo(x, y)
    } else if (tool === 'rectangle') {
      // Start rectangle (will be drawn on mouse up)
    } else if (tool === 'circle') {
      // Start circle (will be drawn on mouse up)
    } else if (tool === 'line' || tool === 'arrow') {
      // Start line/arrow (will be drawn on mouse up)
    }
  }, [tool, color, brushSize, zoom])

  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing) return

    const canvas = canvasRef.current
    const ctx = ctxRef.current
    if (!canvas || !ctx) return

    const rect = canvas.getBoundingClientRect()
    const x = (e.clientX - rect.left) / zoom
    const y = (e.clientY - rect.top) / zoom

    if (tool === 'brush') {
      ctx.lineTo(x, y)
      ctx.stroke()
    }
    // For other tools, we'll draw on mouse up
  }, [isDrawing, tool, zoom])

  const handleMouseUp = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !startPoint) return

    const canvas = canvasRef.current
    const ctx = ctxRef.current
    if (!canvas || !ctx) return

    const rect = canvas.getBoundingClientRect()
    const x = (e.clientX - rect.left) / zoom
    const y = (e.clientY - rect.top) / zoom

    console.log(`ðŸŽ¯ MOUSE UP - ${tool} tool from (${Math.round(startPoint.x)}, ${Math.round(startPoint.y)}) to (${Math.round(x)}, ${Math.round(y)})`)

    // Set drawing properties
    ctx.strokeStyle = color
    ctx.lineWidth = brushSize
    ctx.lineCap = 'round'
    ctx.lineJoin = 'round'

    if (tool === 'rectangle') {
      const width = x - startPoint.x
      const height = y - startPoint.y
      ctx.strokeRect(startPoint.x, startPoint.y, width, height)
      console.log('âœ… RECTANGLE - Created successfully')
      
    } else if (tool === 'circle') {
      const radius = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2))
      ctx.beginPath()
      ctx.arc(startPoint.x, startPoint.y, radius, 0, 2 * Math.PI)
      ctx.stroke()
      console.log('âœ… CIRCLE - Created successfully')
      
    } else if (tool === 'line') {
      ctx.beginPath()
      ctx.moveTo(startPoint.x, startPoint.y)
      ctx.lineTo(x, y)
      ctx.stroke()
      console.log('âœ… LINE - Created successfully')
      
    } else if (tool === 'arrow') {
      drawArrow(ctx, startPoint.x, startPoint.y, x, y)
      console.log('âœ… ARROW - Created successfully')
    }

    if (tool !== 'select') {
      // Add to objects list and save state
      setObjects(prev => [...prev, {
        type: tool,
        startPoint,
        endPoint: { x, y },
        color,
        brushSize,
        timestamp: Date.now()
      }])
      saveState()
    }

    setIsDrawing(false)
    setStartPoint(null)
  }, [isDrawing, startPoint, tool, color, brushSize, zoom, drawArrow, saveState])

  const undo = useCallback(() => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1
      const imageData = history[newIndex]
      ctxRef.current?.putImageData(imageData, 0, 0)
      setHistoryIndex(newIndex)
      console.log('â†©ï¸ UNDO - Performed successfully')
    }
  }, [history, historyIndex])

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1
      const imageData = history[newIndex]
      ctxRef.current?.putImageData(imageData, 0, 0)
      setHistoryIndex(newIndex)
      console.log('â†ªï¸ REDO - Performed successfully')
    }
  }, [history, historyIndex])

  const clear = useCallback(() => {
    const canvas = canvasRef.current
    const ctx = ctxRef.current
    if (!canvas || !ctx) return

    ctx.fillStyle = '#ffffff'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    setObjects([])
    saveState()
    console.log('ðŸ§¹ CLEAR - Canvas cleared successfully')
  }, [saveState])

  const exportCanvas = useCallback((format: string = 'png') => {
    const canvas = canvasRef.current
    if (!canvas) return ''

    return canvas.toDataURL(`image/${format}`, 0.9)
  }, [])

  const handleZoomIn = () => setZoom(prev => Math.min(prev * 1.2, 3))
  const handleZoomOut = () => setZoom(prev => Math.max(prev * 0.8, 0.3))
  const handleFitToScreen = () => setZoom(1)

  // Expose methods through ref
  useImperativeHandle(ref, () => ({
    undo,
    redo,
    clear,
    exportCanvas
  }))

  return (
    <Card className="bg-slate-800/50 border-slate-600 h-full flex flex-col">
      <CardContent className="p-4 flex-1 flex flex-col">
        {/* Canvas Controls */}
        <div className="flex items-center gap-2 mb-4">
          <Button
            size="sm"
            onClick={handleZoomOut}
            className="bg-slate-700 hover:bg-slate-600 text-white"
          >
            <ZoomOut className="w-4 h-4" />
          </Button>
          
          <Button
            size="sm"
            onClick={handleFitToScreen}
            className="bg-slate-700 hover:bg-slate-600 text-white"
          >
            <Maximize2 className="w-4 h-4" />
          </Button>
          
          <Button
            size="sm"
            onClick={handleZoomIn}
            className="bg-slate-700 hover:bg-slate-600 text-white"
          >
            <ZoomIn className="w-4 h-4" />
          </Button>

          <div className="text-sm text-slate-300 ml-auto">
            {Math.round(zoom * 100)}% zoom | {objects.length} objects | Tool: {tool}
          </div>
        </div>

        {/* Canvas Container */}
        <div className="flex-1 bg-slate-900 rounded-lg p-4 relative flex items-center justify-center min-h-96 border-2 border-purple-500/50">
          <canvas
            ref={canvasRef}
            className="border-4 border-purple-400 bg-white shadow-2xl rounded-lg cursor-crosshair"
            style={{
              transform: `scale(${zoom})`,
              transformOrigin: 'center center',
              maxWidth: '100%',
              maxHeight: '100%'
            }}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
          />
        </div>
      </CardContent>
    </Card>
  )
})

SimpleWorkingCanvas.displayName = 'SimpleWorkingCanvas'

export { SimpleWorkingCanvas }